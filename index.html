<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>离子主动运输模拟器 - Ion Transport Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .simulation-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .value-display {
            text-align: center;
            font-weight: bold;
            color: #667eea;
            margin-top: 5px;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #simulationCanvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: linear-gradient(180deg, #e3f2fd 0%, #f3e5f5 100%);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        .graph-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .graph-container h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        #transportGraph {
            border: 2px solid #dee2e6;
            border-radius: 5px;
            background: white;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            #simulationCanvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧬 离子主动运输模拟器</h1>
    </div>

    <div class="simulation-container">
        <div class="controls">
            <div class="control-group">
                <h3>转运蛋白数量</h3>
                <div class="slider-container">
                    <label>膜上转运蛋白数量</label>
                    <input type="range" id="proteinCount" class="slider" min="0" max="10" value="3">
                    <div class="value-display" id="proteinValue">3</div>
                </div>
            </div>

            <div class="control-group">
                <h3>细胞能量水平</h3>
                <div class="slider-container">
                    <label>ATP浓度 (mM)</label>
                    <input type="range" id="atpLevel" class="slider" min="0" max="10" value="5" step="0.1">
                    <div class="value-display" id="atpValue">5.0 mM</div>
                </div>
            </div>

            <div class="control-group">
                <h3>细胞外离子浓度</h3>
                <div class="slider-container">
                    <label>Na⁺浓度 (mM)</label>
                    <input type="range" id="naConcentration" class="slider" min="0" max="200" value="100">
                    <div class="value-display" id="naValue">100 mM</div>
                </div>
            </div>

            <div class="control-group">
                <h3>控制面板</h3>
                <button id="startBtn">开始模拟</button>
                <button id="pauseBtn" disabled>暂停</button>
                <button id="resetBtn">重置</button>
            </div>
        </div>

        <canvas id="simulationCanvas" width="800" height="400"></canvas>

        <div class="graph-container">
            <h3>运输速率变化图</h3>
            <canvas id="transportGraph" width="760" height="200"></canvas>
        </div>
    </div>

    <script>
        class IonTransportSimulation {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.graphCanvas = document.getElementById('transportGraph');
                this.graphCtx = this.graphCanvas.getContext('2d');
                
                this.isRunning = false;
                this.frameCount = 0;
                this.transportRate = 0;
                this.intracellularIons = 0;
                this.energyConsumption = 0;
                this.efficiency = 0;
                
                this.ions = [];
                this.proteins = [];
                this.transportHistory = [];
                
                this.membraneX = 400; // 细胞膜位置
                this.membraneWidth = 40; // 细胞膜宽度
                
                this.initializeSimulation();
                this.setupEventListeners();
                this.draw();
                this.updateGraph(); // 初始绘制图表
            }

            initializeSimulation() {
                // 初始化转运蛋白 - 分布在细胞膜上
                this.proteins = [];
                const proteinCount = parseInt(document.getElementById('proteinCount').value);
                
                // 在细胞膜上均匀分布转运蛋白
                for (let i = 0; i < proteinCount; i++) {
                    const y = 50 + (i * (this.canvas.height - 100) / Math.max(1, proteinCount - 1));
                    this.proteins.push({
                        x: this.membraneX,
                        y: y,
                        active: false
                    });
                }

                // 初始化离子
                this.ions = [];
                const naConcentration = parseInt(document.getElementById('naConcentration').value);
                
                // 细胞外离子（低浓度）
                for (let i = 0; i < naConcentration / 8; i++) { // 细胞外离子数量较少
                    this.ions.push({
                        x: Math.random() * (this.membraneX - 50) + 25,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        transported: false,
                        color: '#FF6B6B'
                    });
                }

                // 细胞内离子（高浓度）
                for (let i = 0; i < naConcentration / 3; i++) { // 细胞内离子数量较多
                    this.ions.push({
                        x: this.membraneX + 50 + Math.random() * (this.canvas.width - this.membraneX - 100),
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        transported: true, // 标记为细胞内离子
                        color: '#FF6B6B'
                    });
                }
            }

            setupEventListeners() {
                // 滑块事件
                document.getElementById('proteinCount').addEventListener('input', (e) => {
                    document.getElementById('proteinValue').textContent = e.target.value;
                    this.initializeSimulation();
                    this.updateGraph(); // 参数变化时更新图表
                });

                document.getElementById('atpLevel').addEventListener('input', (e) => {
                    document.getElementById('atpValue').textContent = e.target.value + ' mM';
                    this.updateGraph(); // 参数变化时更新图表
                });

                document.getElementById('naConcentration').addEventListener('input', (e) => {
                    document.getElementById('naValue').textContent = e.target.value + ' mM';
                    this.initializeSimulation();
                    this.updateGraph(); // 参数变化时更新图表
                });

                // 按钮事件
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            start() {
                this.isRunning = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                this.gameLoop();
            }

            pause() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
            }

            reset() {
                this.pause();
                this.frameCount = 0;
                this.transportRate = 0;
                this.intracellularIons = 0;
                this.energyConsumption = 0;
                this.efficiency = 0;
                this.transportHistory = [];
                this.initializeSimulation();
                this.draw();
                this.updateGraph();
            }

            gameLoop() {
                if (!this.isRunning) return;

                this.update();
                this.draw();
                this.frameCount++;

                requestAnimationFrame(() => this.gameLoop());
            }

            // 计算运输速率（基于三个参数的饱和函数）
            calculateTransportRate() {
                const proteinCount = parseInt(document.getElementById('proteinCount').value);
                const atpLevel = parseFloat(document.getElementById('atpLevel').value);
                const naConcentration = parseInt(document.getElementById('naConcentration').value);

                // 转运蛋白饱和函数：Vmax * (n / (n + K1))
                const proteinFactor = (proteinCount / (proteinCount + 2)); // K1 = 2

                // ATP饱和函数：Vmax * (ATP / (ATP + K2))
                const atpFactor = (atpLevel / (atpLevel + 3)); // K2 = 3

                // 离子浓度饱和函数：Vmax * (C / (C + K3))
                const concentrationFactor = (naConcentration / (naConcentration + 50)); // K3 = 50

                // 综合运输速率 = 基础速率 * 三个因子的乘积
                const baseRate = 10; // 基础运输速率
                const transportRate = baseRate * proteinFactor * atpFactor * concentrationFactor;

                return transportRate;
            }

            update() {
                // 更新离子位置
                this.ions.forEach(ion => {
                    if (!ion.transported) {
                        // 细胞外离子可以移动
                        ion.x += ion.vx;
                        ion.y += ion.vy;

                        // 边界检测 - 不能穿过细胞膜
                        if (ion.x < 0 || ion.x > this.membraneX - 25) ion.vx *= -1;
                        if (ion.y < 0 || ion.y > this.canvas.height) ion.vy *= -1;

                        // 保持在边界内
                        ion.x = Math.max(0, Math.min(this.membraneX - 25, ion.x));
                        ion.y = Math.max(0, Math.min(this.canvas.height, ion.y));
                    } else {
                        // 细胞内离子也可以轻微移动
                        ion.x += ion.vx * 0.3;
                        ion.y += ion.vy * 0.3;

                        // 边界检测 - 不能离开细胞内区域
                        if (ion.x < this.membraneX + 50 || ion.x > this.canvas.width - 25) ion.vx *= -1;
                        if (ion.y < 0 || ion.y > this.canvas.height) ion.vy *= -1;

                        // 保持在边界内
                        ion.x = Math.max(this.membraneX + 50, Math.min(this.canvas.width - 25, ion.x));
                        ion.y = Math.max(0, Math.min(this.canvas.height, ion.y));
                    }
                });

                // 检查细胞外离子与转运蛋白的相互作用
                this.proteins.forEach(protein => {
                    protein.active = false;

                    this.ions.forEach(ion => {
                        if (!ion.transported) { // 只处理细胞外离子
                            const distance = Math.sqrt(
                                Math.pow(ion.x - protein.x, 2) + 
                                Math.pow(ion.y - protein.y, 2)
                            );

                            if (distance < 30) {
                                protein.active = true;

                                // 运输概率基于ATP浓度
                                const atpLevel = parseFloat(document.getElementById('atpLevel').value);
                                const transportProbability = (atpLevel / 10) * 0.05; // 提高运输概率

                                if (Math.random() < transportProbability) {
                                    // 标记为已运输
                                    ion.transported = true;
                                    // 移动到细胞内位置
                                    ion.x = protein.x + 50;
                                    ion.y = protein.y;
                                    // 设置细胞内运动速度
                                    ion.vx = (Math.random() - 0.5) * 1;
                                    ion.vy = (Math.random() - 0.5) * 1;
                                    this.intracellularIons++;
                                    this.energyConsumption += 1;
                                }
                            }
                        }
                    });
                });

                // 计算运输速率（基于参数，不考虑随机运动）
                this.transportRate = this.calculateTransportRate();
            }

            drawPhospholipidBilayer() {
                const ctx = this.ctx;
                const x = this.membraneX;
                const width = this.membraneWidth;
                const height = this.canvas.height;

                // 绘制磷脂双分子层
                ctx.save();
                
                // 外层磷脂头部（左侧）
                ctx.fillStyle = '#B0B0B0';
                ctx.fillRect(x - width/2, 0, width/4, height);
                
                // 内层磷脂头部（右侧）
                ctx.fillStyle = '#B0B0B0';
                ctx.fillRect(x + width/4, 0, width/4, height);
                
                // 磷脂尾部（黄色波浪状）
                ctx.fillStyle = '#FFD700';
                
                // 左侧尾部
                ctx.beginPath();
                for (let y = 0; y < height; y += 10) {
                    const wave = Math.sin(y * 0.1) * 3;
                    ctx.lineTo(x - width/4 + wave, y);
                }
                ctx.lineTo(x - width/4, height);
                ctx.lineTo(x - width/2, height);
                ctx.lineTo(x - width/2, 0);
                ctx.closePath();
                ctx.fill();
                
                // 右侧尾部
                ctx.beginPath();
                for (let y = 0; y < height; y += 10) {
                    const wave = Math.sin(y * 0.1) * 3;
                    ctx.lineTo(x + width/2 - wave, y);
                }
                ctx.lineTo(x + width/2, height);
                ctx.lineTo(x + width/4, height);
                ctx.lineTo(x + width/4, 0);
                ctx.closePath();
                ctx.fill();
                
                // 绘制磷脂头部细节
                ctx.fillStyle = '#A0A0A0';
                for (let y = 0; y < height; y += 15) {
                    // 左侧头部
                    ctx.beginPath();
                    ctx.ellipse(x - width/2 + width/8, y, width/8, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 右侧头部
                    ctx.beginPath();
                    ctx.ellipse(x + width/2 - width/8, y, width/8, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制磷脂双分子层
                this.drawPhospholipidBilayer();

                // 绘制转运蛋白（紫色圆球，比细胞膜宽）
                this.proteins.forEach(protein => {
                    this.ctx.save();
                    this.ctx.translate(protein.x, protein.y);
                    
                    // 转运蛋白主体（紫色圆球）
                    this.ctx.fillStyle = protein.active ? '#9C27B0' : '#7B1FA2';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 25, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // 转运蛋白边框
                    this.ctx.strokeStyle = '#4A148C';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                });

                // 绘制所有离子
                this.ions.forEach(ion => {
                    this.ctx.fillStyle = ion.color; // 始终使用红色
                    this.ctx.beginPath();
                    this.ctx.arc(ion.x, ion.y, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                });

                // 绘制ATP分子
                const atpLevel = parseFloat(document.getElementById('atpLevel').value);
                for (let i = 0; i < atpLevel * 2; i++) {
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(450 + (i % 10) * 20, 50 + Math.floor(i / 10) * 20, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制区域标签
                this.ctx.fillStyle = '#666';
                this.ctx.font = '16px Arial';
                this.ctx.fillText('细胞外', 50, 30);
                this.ctx.fillText('细胞内', 450, 30);
            }

            updateGraph() {
                // 计算当前运输速率
                const currentRate = this.calculateTransportRate();
                
                // 添加到历史记录
                this.transportHistory.push({
                    time: this.frameCount / 60,
                    rate: currentRate
                });

                // 保持最近100个数据点
                if (this.transportHistory.length > 100) {
                    this.transportHistory.shift();
                }

                this.drawGraph();
            }

            drawGraph() {
                const ctx = this.graphCtx;
                const canvas = this.graphCanvas;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (this.transportHistory.length < 2) return;

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, 20);
                ctx.lineTo(50, canvas.height - 20);
                ctx.lineTo(canvas.width - 20, canvas.height - 20);
                ctx.stroke();

                // 绘制标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('运输速率', 10, 15);
                ctx.fillText('时间 (秒)', canvas.width - 60, canvas.height - 5);

                // 绘制数据线
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();

                const maxRate = Math.max(...this.transportHistory.map(d => d.rate));
                const maxTime = Math.max(...this.transportHistory.map(d => d.time));

                this.transportHistory.forEach((point, index) => {
                    const x = 50 + (point.time / maxTime) * (canvas.width - 70);
                    const y = canvas.height - 20 - (point.rate / maxRate) * (canvas.height - 40);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // 显示当前运输速率值
                ctx.fillStyle = '#667eea';
                ctx.font = '14px Arial';
                ctx.fillText(`当前运输速率: ${this.transportHistory[this.transportHistory.length - 1].rate.toFixed(2)}`, 10, canvas.height - 5);
            }
        }

        // 初始化模拟器
        const simulation = new IonTransportSimulation();
    </script>
</body>
</html>
