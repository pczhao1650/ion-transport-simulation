<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>离子主动运输模拟器 - Ion Transport Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .simulation-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .value-display {
            text-align: center;
            font-weight: bold;
            color: #667eea;
            margin-top: 5px;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #simulationCanvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: linear-gradient(180deg, #e3f2fd 0%, #f3e5f5 100%);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        .graph-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .graph-container h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        #transportGraph {
            border: 2px solid #dee2e6;
            border-radius: 5px;
            background: white;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            #simulationCanvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>离子主动运输模拟器</h1>
    </div>

    <div class="simulation-container">
        <div class="controls">
            <div class="control-group">
                <h3>转运蛋白数量</h3>
                <div class="slider-container">
                    <input type="range" id="proteinCount" class="slider" min="0" max="10" value="0">
                    <div class="value-display" id="proteinValue">0</div>
                </div>
            </div>

            <div class="control-group">
                <h3>细胞能量水平</h3>
                <div class="slider-container">
                    <input type="range" id="atpLevel" class="slider" min="0" max="30" value="0" step="1">
                    <div class="value-display" id="atpValue">0</div>
                </div>
            </div>

            <div class="control-group">
                <h3>细胞外离子浓度</h3>
                <div class="slider-container">
                    <input type="range" id="naConcentration" class="slider" min="0" max="30" value="0">
                    <div class="value-display" id="naValue">0</div>
                </div>
            </div>

            <div class="control-group">
                <h3>控制面板</h3>
                <button id="startBtn">开始模拟</button>
                <button id="pauseBtn" disabled>暂停</button>
                <button id="resetBtn">重置</button>
            </div>
        </div>

        <canvas id="simulationCanvas" width="800" height="400"></canvas>

        <div class="graph-container">
            <h3>运输速率变化图</h3>
            <canvas id="transportGraph" width="760" height="200"></canvas>
        </div>
    </div>

    <script>
        class IonTransportSimulation {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.graphCanvas = document.getElementById('transportGraph');
                this.graphCtx = this.graphCanvas.getContext('2d');
                
                this.isRunning = false;
                this.frameCount = 0;
                this.transportRate = 0;
                this.intracellularIons = 0;
                this.energyConsumption = 0;
                this.efficiency = 0;
                
                this.ions = [];
                this.proteins = [];
                this.transportHistory = [];
                
                this.membraneX = 400; // 细胞膜位置
                this.membraneWidth = 40; // 细胞膜宽度
                
                this.initializeSimulation();
                this.setupEventListeners();
                this.draw();
                this.updateGraph(); // 初始绘制图表
            }

            initializeSimulation() {
                // 初始化转运蛋白 - 分布在细胞膜上
                this.proteins = [];
                const proteinCount = parseInt(document.getElementById('proteinCount').value);
                
                // 在细胞膜上均匀分布转运蛋白
                for (let i = 0; i < proteinCount; i++) {
                    const y = 50 + (i * (this.canvas.height - 100) / Math.max(1, proteinCount - 1));
                    this.proteins.push({
                        x: this.membraneX,
                        y: y,
                        active: false
                    });
                }

                // 初始化离子
                this.ions = [];
                const naConcentration = parseInt(document.getElementById('naConcentration').value);
                
                // 细胞外离子数量（根据浓度调整，范围0-30对应0-30个离子）
                for (let i = 0; i < naConcentration; i++) {
                    this.ions.push({
                        x: Math.random() * (this.membraneX - 50) + 25,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        transported: false,
                        color: '#FF6B6B'
                    });
                }

                // 细胞内离子数量（固定为50个，确保始终大于细胞外浓度）
                for (let i = 0; i < 50; i++) {
                    this.ions.push({
                        x: this.membraneX + 50 + Math.random() * (this.canvas.width - this.membraneX - 100),
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        transported: true, // 标记为细胞内离子
                        color: '#FF6B6B'
                    });
                }
            }

            setupEventListeners() {
                // 滑块事件
                document.getElementById('proteinCount').addEventListener('input', (e) => {
                    document.getElementById('proteinValue').textContent = e.target.value;
                    this.initializeSimulation();
                    this.updateGraph(); // 参数变化时更新图表
                });

                document.getElementById('atpLevel').addEventListener('input', (e) => {
                    document.getElementById('atpValue').textContent = e.target.value;
                    this.updateGraph(); // 参数变化时更新图表
                });

                document.getElementById('naConcentration').addEventListener('input', (e) => {
                    document.getElementById('naValue').textContent = e.target.value;
                    this.initializeSimulation();
                    this.updateGraph(); // 参数变化时更新图表
                });

                // 按钮事件
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            start() {
                this.isRunning = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                this.gameLoop();
            }

            pause() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
            }

            reset() {
                this.pause();
                this.frameCount = 0;
                this.transportRate = 0;
                this.intracellularIons = 0;
                this.energyConsumption = 0;
                this.efficiency = 0;
                this.transportHistory = [];
                this.initializeSimulation();
                this.draw();
                this.updateGraph();
            }

            gameLoop() {
                if (!this.isRunning) return;

                this.update();
                this.draw();
                this.frameCount++;

                // 每30帧（约0.5秒）更新一次图表
                if (this.frameCount % 30 === 0) {
                    this.updateGraph();
                }

                requestAnimationFrame(() => this.gameLoop());
            }

            // 计算运输速率（简单直观的逻辑，适合高中生物教学）
            calculateTransportRate() {
                const proteinCount = parseInt(document.getElementById('proteinCount').value);
                const atpLevel = parseFloat(document.getElementById('atpLevel').value);
                const naConcentration = parseInt(document.getElementById('naConcentration').value);

                // 如果没有转运蛋白，速率为0
                if (proteinCount === 0) {
                    return 0;
                }

                // 转运蛋白因子：线性增长，最大值为10
                const proteinFactor = Math.min(proteinCount, 10) / 10;

                // ATP饱和点 = 转运蛋白数量 × 2
                const atpSaturation = proteinCount * 2;
                const atpFactor = Math.min(atpLevel, atpSaturation) / atpSaturation;

                // 离子浓度饱和点 = 转运蛋白数量 × 2
                const concentrationSaturation = proteinCount * 2;
                const concentrationFactor = Math.min(naConcentration, concentrationSaturation) / concentrationSaturation;

                // 综合运输速率 = 基础速率 × 三个因子的乘积
                const baseRate = 10;
                const transportRate = baseRate * proteinFactor * atpFactor * concentrationFactor;

                return transportRate;
            }

            update() {
                // 更新离子位置 - 使用随机游走模拟布朗运动
                this.ions.forEach(ion => {
                    if (!ion.transported) {
                        // 细胞外离子：随机游走（布朗运动）
                        // 每帧随机改变一点速度方向
                        ion.vx += (Math.random() - 0.5) * 0.2;
                        ion.vy += (Math.random() - 0.5) * 0.2;
                        
                        // 限制速度大小
                        const speed = Math.sqrt(ion.vx * ion.vx + ion.vy * ion.vy);
                        if (speed > 1.5) {
                            ion.vx = (ion.vx / speed) * 1.5;
                            ion.vy = (ion.vy / speed) * 1.5;
                        }
                        
                        ion.x += ion.vx;
                        ion.y += ion.vy;

                        // 边界检测 - 只限制画布左侧和上下边界
                        if (ion.x < 10) {
                            ion.x = 10;
                            ion.vx = Math.abs(ion.vx) * 0.5; // 向内移动
                        }
                        // 移除细胞膜处的边界限制，让离子可以自由接近转运蛋白
                        if (ion.y < 10) {
                            ion.y = 10;
                            ion.vy = Math.abs(ion.vy) * 0.5;
                        }
                        if (ion.y > this.canvas.height - 10) {
                            ion.y = this.canvas.height - 10;
                            ion.vy = -Math.abs(ion.vy) * 0.5;
                        }
                    } else {
                        // 细胞内离子：更缓慢的随机游走
                        ion.vx += (Math.random() - 0.5) * 0.1;
                        ion.vy += (Math.random() - 0.5) * 0.1;
                        
                        // 限制速度
                        const speed = Math.sqrt(ion.vx * ion.vx + ion.vy * ion.vy);
                        if (speed > 0.8) {
                            ion.vx = (ion.vx / speed) * 0.8;
                            ion.vy = (ion.vy / speed) * 0.8;
                        }
                        
                        ion.x += ion.vx;
                        ion.y += ion.vy;

                        // 边界检测 - 柔和地限制在细胞内区域
                        if (ion.x < this.membraneX + 60) {
                            ion.x = this.membraneX + 60;
                            ion.vx = Math.abs(ion.vx) * 0.5;
                        }
                        if (ion.x > this.canvas.width - 10) {
                            ion.x = this.canvas.width - 10;
                            ion.vx = -Math.abs(ion.vx) * 0.5;
                        }
                        if (ion.y < 10) {
                            ion.y = 10;
                            ion.vy = Math.abs(ion.vy) * 0.5;
                        }
                        if (ion.y > this.canvas.height - 10) {
                            ion.y = this.canvas.height - 10;
                            ion.vy = -Math.abs(ion.vy) * 0.5;
                        }
                    }
                });

                // 检查细胞外离子与转运蛋白的相互作用
                this.proteins.forEach(protein => {
                    protein.active = false;

                    this.ions.forEach(ion => {
                        if (!ion.transported && !ion.justTransported) { // 只处理细胞外离子，且未被标记为刚运输过的
                            const distance = Math.sqrt(
                                Math.pow(ion.x - protein.x, 2) + 
                                Math.pow(ion.y - protein.y, 2)
                            );

                            if (distance < 30) {
                                protein.active = true;

                                // 100%运输，不需要概率判断
                                // 标记为已运输
                                ion.transported = true;
                                ion.justTransported = true; // 防止重复触发
                                // 移动到细胞内位置
                                ion.x = protein.x + 50;
                                ion.y = protein.y;
                                // 设置细胞内运动速度
                                ion.vx = (Math.random() - 0.5) * 1;
                                ion.vy = (Math.random() - 0.5) * 1;
                                this.intracellularIons++;
                                this.energyConsumption += 1;
                            }
                        }
                    });
                });

                // 阻止未被运输的细胞外离子穿过细胞膜
                this.ions.forEach(ion => {
                    if (!ion.transported && ion.x > this.membraneX - 20) {
                        ion.x = this.membraneX - 20;
                        ion.vx = -Math.abs(ion.vx) * 0.5; // 反弹回细胞外
                    }
                });

                // 计算运输速率（基于参数，不考虑随机运动）
                this.transportRate = this.calculateTransportRate();
            }

            drawPhospholipidBilayer() {
                const ctx = this.ctx;
                const x = this.membraneX;
                const width = this.membraneWidth;
                const height = this.canvas.height;

                // 绘制磷脂双分子层
                ctx.save();
                
                // 外层磷脂头部（左侧）
                ctx.fillStyle = '#B0B0B0';
                ctx.fillRect(x - width/2, 0, width/4, height);
                
                // 内层磷脂头部（右侧）
                ctx.fillStyle = '#B0B0B0';
                ctx.fillRect(x + width/4, 0, width/4, height);
                
                // 磷脂尾部（黄色波浪状）
                ctx.fillStyle = '#FFD700';
                
                // 左侧尾部
                ctx.beginPath();
                for (let y = 0; y < height; y += 10) {
                    const wave = Math.sin(y * 0.1) * 3;
                    ctx.lineTo(x - width/4 + wave, y);
                }
                ctx.lineTo(x - width/4, height);
                ctx.lineTo(x - width/2, height);
                ctx.lineTo(x - width/2, 0);
                ctx.closePath();
                ctx.fill();
                
                // 右侧尾部
                ctx.beginPath();
                for (let y = 0; y < height; y += 10) {
                    const wave = Math.sin(y * 0.1) * 3;
                    ctx.lineTo(x + width/2 - wave, y);
                }
                ctx.lineTo(x + width/2, height);
                ctx.lineTo(x + width/4, height);
                ctx.lineTo(x + width/4, 0);
                ctx.closePath();
                ctx.fill();
                
                // 绘制磷脂头部细节
                ctx.fillStyle = '#A0A0A0';
                for (let y = 0; y < height; y += 15) {
                    // 左侧头部
                    ctx.beginPath();
                    ctx.ellipse(x - width/2 + width/8, y, width/8, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 右侧头部
                    ctx.beginPath();
                    ctx.ellipse(x + width/2 - width/8, y, width/8, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 绘制磷脂双分子层
                this.drawPhospholipidBilayer();

                // 绘制转运蛋白（紫色圆球，比细胞膜宽）
                this.proteins.forEach(protein => {
                    this.ctx.save();
                    this.ctx.translate(protein.x, protein.y);
                    
                    // 转运蛋白主体（紫色圆球）
                    this.ctx.fillStyle = protein.active ? '#9C27B0' : '#7B1FA2';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 25, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // 转运蛋白边框
                    this.ctx.strokeStyle = '#4A148C';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                });

                // 绘制所有离子
                this.ions.forEach(ion => {
                    this.ctx.fillStyle = ion.color; // 始终使用红色
                    this.ctx.beginPath();
                    this.ctx.arc(ion.x, ion.y, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                });

                // 绘制ATP分子
                const atpLevel = parseFloat(document.getElementById('atpLevel').value);
                for (let i = 0; i < atpLevel * 2; i++) {
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(450 + (i % 10) * 20, 50 + Math.floor(i / 10) * 20, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制区域标签
                this.ctx.fillStyle = '#666';
                this.ctx.font = '16px Arial';
                this.ctx.fillText('细胞外', 50, 30);
                this.ctx.fillText('细胞内', 450, 30);
            }

            updateGraph() {
                // 计算当前运输速率
                const currentRate = this.calculateTransportRate();
                
                // 添加到历史记录（保留所有数据，不删除）
                this.transportHistory.push({
                    time: this.frameCount / 60,
                    rate: currentRate
                });

                // 不删除历史数据，全部保留

                this.drawGraph();
            }

            drawGraph() {
                const ctx = this.graphCtx;
                const canvas = this.graphCanvas;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (this.transportHistory.length < 2) return;

                // 固定时间窗口：显示最近50秒的数据
                const timeWindow = 50; // 秒
                const currentTime = this.transportHistory[this.transportHistory.length - 1].time;
                const startTime = Math.max(0, currentTime - timeWindow);

                // 筛选出时间窗口内的数据
                const visibleData = this.transportHistory.filter(point => point.time >= startTime);

                if (visibleData.length < 2) return;

                // 绘制坐标轴
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, 20);
                ctx.lineTo(50, canvas.height - 20);
                ctx.lineTo(canvas.width - 20, canvas.height - 20);
                ctx.stroke();

                // 绘制标签
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('运输速率', 10, 15);
                ctx.fillText('时间 (秒)', canvas.width - 60, canvas.height - 5);

                // 绘制时间刻度
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                const endTime = currentTime;
                for (let t = Math.ceil(startTime / 10) * 10; t <= endTime; t += 10) {
                    const x = 50 + ((t - startTime) / timeWindow) * (canvas.width - 70);
                    ctx.fillText(t.toFixed(0), x - 10, canvas.height - 5);
                }

                // 绘制数据线
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();

                const maxRate = Math.max(...visibleData.map(d => d.rate), 0.1); // 至少0.1避免除以0

                visibleData.forEach((point, index) => {
                    // X轴：时间映射到固定窗口
                    const x = 50 + ((point.time - startTime) / timeWindow) * (canvas.width - 70);
                    // Y轴：根据速率值缩放
                    const y = canvas.height - 20 - (point.rate / maxRate) * (canvas.height - 40);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // 显示当前运输速率值
                ctx.fillStyle = '#667eea';
                ctx.font = '14px Arial';
                const currentRate = this.transportHistory[this.transportHistory.length - 1].rate.toFixed(2);
                ctx.fillText(`当前运输速率: ${currentRate}`, 10, canvas.height - 5);
            }
        }

        // 初始化模拟器
        const simulation = new IonTransportSimulation();
    </script>
</body>
</html>
